# アーキテクチャ設計

## 全体構成

本システムは3層アーキテクチャを採用している。クライアントからのHTTPリクエストはAPI層で受け取り、サービス層でビジネスロジックを処理し、データアクセス層を通じてデータベースや外部サービスと通信する。

### API層

FastAPIのルーターを使用して、RESTfulなエンドポイントを提供する。7つのルーターモジュールがあり、それぞれ異なるリソースを管理する。

- **tenants**：テナントのCRUD操作
- **models**：AIモデル定義の管理
- **conversations**：会話管理とエージェント実行
- **skills**：Agent Skillsの管理
- **mcp_servers**：MCPサーバー設定の管理
- **usage**：使用状況とコストの取得
- **workspace**：ファイルアップロード・ダウンロード

API層の責務は、リクエストの受信、バリデーション、レスポンスのフォーマット、SSEストリーミングの管理である。ビジネスロジックはサービス層に委譲する。

### サービス層

ビジネスロジックを実装する中核層。各サービスは単一責任の原則に従い、特定のドメインを担当する。

- **ExecuteService**：エージェント実行のコア機能（最も重要）
- **ConversationService**：会話のCRUD操作
- **TenantService**：テナント管理
- **ModelService**：モデル定義とコスト計算
- **SkillService**：スキルファイルとメタデータの管理
- **McpServerService**：MCPサーバー設定の管理
- **UsageService**：使用状況の記録と集計
- **WorkspaceService**：S3ワークスペース管理
- **OpenApiMcpService**：OpenAPI仕様からMCPツールへの変換

サービス層はデータベースセッションを受け取り、トランザクション管理を行う。複数のリポジトリ操作をまたぐトランザクションもサービス層で制御する。

### データアクセス層

SQLAlchemy 2.0の非同期セッションを使用してPostgreSQLにアクセスする。ORMモデルは10個のテーブルに対応している。

---

## マルチエージェントアーキテクチャ

本システムはClaude Agent SDKを使用して、階層的なエージェント構造を実現している。

### メインエージェント

ユーザーからのリクエストを受け取り、適切なツールを選択・実行するメインのAIエージェント。通常はClaude Sonnetモデルを使用する。メインエージェントは以下を行う。

- ユーザー入力の解釈と意図理解
- 必要なツールの判断と呼び出し
- ツール結果の統合と最終レスポンスの生成

### サブエージェント

メインエージェントが複雑なタスクを分割する際に、Taskツールを通じて起動される補助エージェント。通常はClaude Haikuモデルを使用してコスト最適化を図る。サブエージェントは並列実行が可能で、複数のタスクを同時に処理できる。

### ツール群

エージェントが使用できるツールは以下のカテゴリに分類される。

1. **組み込みツール**：ファイル読み書き（Read, Write, Edit）、コマンド実行（Bash）、検索（Grep, Glob）など
2. **MCPサーバーツール**：外部APIやシステムと連携するツール
3. **Agent Skills**：テナント固有のカスタム能力

---

## 実行フロー

エージェント実行の完全なフローを以下に説明する。

### 1. リクエスト受信

クライアントが`/execute`エンドポイントにPOSTリクエストを送信する。リクエストには、ユーザー入力、実行者情報、MCPトークン（オプション）、優先スキル（オプション）が含まれる。

### 2. バリデーションと準備

API層でリクエストをバリデーションし、テナント・モデル・会話の存在確認を行う。すべての前提条件が満たされていることを確認する。

### 3. 会話ロック取得

同一会話の並列実行を防ぐため、会話ロックを取得する。ロックはインメモリで管理され、タイムアウト付きで自動解放される。

### 4. 実行コンテキスト作成

実行に必要なすべての情報を集約した実行コンテキストを作成する。これには、テナント設定、モデル情報、ワークスペース設定、優先スキルなどが含まれる。

### 5. SDKオプション構築

ExecutionContextから、Claude Agent SDKに渡すオプションを構築する。この過程で以下を行う。

- システムプロンプトの組み立て（テナント設定 + ワークスペース情報 + スキル指示）
- MCPサーバー設定の構築（トークン置換を含む）
- AWS環境変数の設定
- 会話継続時のセッションID設定

### 6. SDK実行

構築したオプションでClaude Agent SDKを初期化し、ユーザー入力をクエリとして送信する。SDKは非同期にメッセージストリームを返す。

### 7. メッセージ処理

SDKから受信した各メッセージを処理し、SSEイベントに変換してクライアントに送信する。同時にメッセージログをデータベースに記録する。メッセージタイプは以下がある。

- **system**：セッション初期化/終了
- **assistant**：テキスト出力、ツール呼び出し、拡張思考
- **user**：ツール実行結果
- **result**：実行完了

### 8. ツール追跡

ToolTrackerがすべてのツール実行を追跡する。特にサブエージェント（Taskツール）の開始・完了を監視し、使用量を個別に集計する。

### 9. 結果処理

実行完了後、以下の後処理を行う。

- セッションIDの更新（会話継続用）
- タイトルの自動生成（初回実行時）
- 使用量ログの保存
- ツール実行ログの保存
- トランザクションのコミット

### 10. ロック解放

会話ロックを解放し、他のリクエストが処理可能な状態にする。

---

## 設計パターン

本システムで使用している主要な設計パターンを説明する。

### Strategy パターン

OptionsBuilderでMCPサーバーの構築戦略を切り替える。サーバータイプ（HTTP, STDIO, OpenAPIなど）に応じて異なる構築ロジックを適用する。

### Builder パターン

ExecutionContextとSDKOptionsの構築に使用。複雑なオブジェクトを段階的に構築し、最終的に不変オブジェクトを生成する。

### Observer パターン

ToolTrackerがツール実行の開始・完了を観察し、状態を追跡する。サブエージェントの並列実行も正確に追跡できる。

### Repository パターン

各サービスがデータアクセスを抽象化し、ビジネスロジックとデータ永続化を分離する。

### Decorator パターン

エラーハンドリングをデコレータとして実装し、サービスメソッドに横断的に適用する。

### Singleton パターン

設定クラス（Settings）をlru_cacheでキャッシュし、アプリケーション全体で単一インスタンスを共有する。

### Async Iterator パターン

executeStreamingメソッドがAsyncGeneratorを返し、SSEイベントを逐次生成する。これにより、メモリ効率の良いストリーミング処理が可能になる。

---

## セキュリティ設計

本システムのセキュリティ設計について説明する。

### 入力バリデーション

Pydanticスキーマにより、すべてのAPIリクエストを厳格にバリデーションする。特に、スキル名やテナントIDには正規表現パターンを適用し、不正な文字を排除する。

### パストラバーサル防止

ファイル操作時に、ベースパスからの相対パスが外部に出ていないことを確認する。path.resolve()を使用してパスを正規化し、startswith()で検証する。

### 機密情報の保護

ログ出力時に機密情報をサニタイズする。AWS認証情報、APIトークン、パスワードなどは[REDACTED]に置換される。

### 会話ロック

同一会話への同時アクセスを防ぎ、データ整合性を保護する。ロックにはタイムアウトを設け、デッドロックを回避する。

### CORS設定

許可されたオリジンのみからのアクセスを受け付ける。本番環境では、具体的なドメインを指定することを推奨する。

---

## スケーラビリティ考慮

本システムのスケーラビリティに関する設計を説明する。

### 非同期処理

すべてのI/O操作を非同期で実行し、スレッドのブロッキングを回避する。これにより、少ないリソースで多数の同時接続を処理できる。

### 接続プール

データベース接続はプールで管理し、接続の生成・破棄コストを削減する。pool_size=10、max_overflow=20の設定で、負荷変動に対応する。

### 会話ロックの分散化

現在はインメモリロックを使用しているが、将来的にはRedisによる分散ロックに置き換えることで、複数インスタンスでのスケールアウトが可能になる設計としている。

### S3ワークスペース

ファイルストレージにS3を使用することで、ローカルディスクに依存せず、ステートレスなアプリケーションサーバーを実現している。

### ステートレス設計

アプリケーションサーバーはステートレスであり、ロードバランサーの背後で水平スケールが可能。セッション状態はすべてデータベースに永続化される。
