# セキュリティ設計

## 概要

本システムのセキュリティ設計について説明する。入力バリデーション、アクセス制御、機密情報保護、エラーハンドリングなどの観点から、実装されているセキュリティ対策を記述する。

---

## 入力バリデーション

### Pydanticによる型検証

すべてのAPIリクエストはPydanticスキーマで定義され、型検証が自動的に行われる。不正な型のデータは400 Bad Requestでリジェクトされる。

### パターン制約

特定のフィールドには正規表現パターンを適用する。

**スキル名**

英数字、アンダースコア、ハイフンのみ許可。パターン：^[a-zA-Z0-9_\-]+$

**テナントID**

長さ制限（最大100文字）を適用。

**ファイル名**

パストラバーサルを防ぐため、「..」を含むパスをリジェクト。

### 長さ制限

文字列フィールドには最大長を設定し、過度に長い入力を防ぐ。

- tenant_id：最大100文字
- model_id：最大100文字
- display_name：最大200文字
- title：最大500文字
- file_path：最大1000文字

---

## パストラバーサル防止

### 検証ロジック

ファイルパスを受け取る際、以下の検証を行う。

1. パスを正規化（path.resolve()相当）
2. 正規化後のパスがベースパスで始まることを確認
3. 「..」を含むパスを明示的にリジェクト

### 適用箇所

- Agent Skills：SKILL.mdファイルの読み書き
- ワークスペース：ファイルのアップロード・ダウンロード

### エラー処理

パストラバーサルが検出された場合、PathTraversalError（403 Forbidden）を返す。

---

## 機密情報保護

### ログサニタイズ

ログ出力前に機密情報をサニタイズする。対象フィールド：

- aws_access_key_id
- aws_secret_access_key
- aws_session_token
- authorization
- password
- token
- api_key
- secret

これらのフィールドは「[REDACTED]」に置換される。

### パターンベースのサニタイズ

以下のパターンに一致する文字列もサニタイズ対象：

- Bearer トークン（Bearer xxx形式）
- Basic認証（Basic xxx形式）

### AWS認証情報

本番環境ではIAMロールの使用を推奨する。環境変数でAWS認証情報を設定する場合でも、アプリケーションログには出力されない。

---

## 認証・認可

### テナント認証

現在の実装では、テナントIDはパスパラメータとして渡される。フロントエンド側で認証を行い、ユーザーが所属するテナントのIDのみを使用することを想定している。

### 将来の拡張ポイント

以下の認証・認可機能は将来的に追加可能な設計となっている。

- JWTトークンによる認証
- API Keyによる認証
- ロールベースアクセス制御（RBAC）
- テナント間のリソース分離の強化

---

## 会話ロック

### 目的

同一会話への同時アクセスを防ぎ、データ整合性を保護する。エージェント実行中に他のリクエストが同じ会話を操作することを防止。

### 実装

インメモリのロックマネージャーを使用。各会話IDに対してasyncio.Lockを作成し、排他制御を行う。

### タイムアウト

- ロック最大保持時間：600秒（10分）
- ロック取得待機時間：5秒

タイムアウトを超えた場合、古いロックは強制解放される。

### エラー処理

ロック取得に失敗した場合、ConversationLockError（409 Conflict）を返す。

---

## CORS設定

### 許可オリジン

CORS_ORIGINS環境変数で許可するオリジンを指定する。カンマ区切りで複数指定可能。

デフォルト：http://localhost:3000,http://localhost:3001

### 本番環境での推奨設定

本番環境では、具体的なドメインのみを許可することを推奨する。ワイルドカード（*）は使用しない。

### CORSヘッダー

以下のヘッダーを設定：

- Access-Control-Allow-Origin：許可されたオリジン
- Access-Control-Allow-Methods：GET, POST, PUT, DELETE, OPTIONS
- Access-Control-Allow-Headers：Content-Type, Authorization, X-Tenant-ID
- Access-Control-Allow-Credentials：true

---

## レート制限

### 設定

RATE_LIMIT_REQUESTS：期間内の最大リクエスト数（デフォルト：100）
RATE_LIMIT_PERIOD：制限期間（秒、デフォルト：60）

### 適用

API全体に適用されるレート制限。過度なリクエストを防ぎ、サービスの安定性を保護する。

---

## ファイルサイズ制限

### 設定

MAX_UPLOAD_FILE_SIZE：最大アップロードサイズ（バイト、デフォルト：104857600 = 100MB）

### 検証タイミング

ファイルアップロード時にサイズをチェック。制限を超える場合はFileSizeError（413 Request Entity Too Large）を返す。

---

## エラーハンドリング

### 例外階層

カスタム例外を階層的に定義し、適切なHTTPステータスコードにマッピング：

- AppError（基底）：500 Internal Server Error
- NotFoundError：404 Not Found
- ValidationError：400 Bad Request
- InactiveResourceError：400 Bad Request
- SecurityError：403 Forbidden
- PathTraversalError：403 Forbidden
- ConversationLockError：409 Conflict
- FileSizeError：413 Request Entity Too Large
- SDKError：500 Internal Server Error

### エラーレスポンス形式

すべてのエラーは統一された形式で返される：

- error.code：エラーコード（NOT_FOUND、VALIDATION_ERROR等）
- error.message：エラーメッセージ

### 内部エラーの秘匿

500系エラーの場合、詳細な内部エラー情報はクライアントに返さない。ログには完全なスタックトレースを記録し、クライアントには一般的なメッセージを返す。

---

## データベースセキュリティ

### 接続の保護

本番環境ではSSL接続を使用することを推奨。DATABASE_URLに「?sslmode=require」を追加。

### SQLインジェクション防止

SQLAlchemy ORMを使用することで、SQLインジェクションを防止。パラメータ化クエリが自動的に使用される。

### 接続プールの管理

pool_pre_ping=Trueにより、使用前に接続の有効性をチェック。不正な接続を使用するリスクを軽減。

---

## SDKセキュリティ

### permission_mode

SDKのpermission_modeを「bypassPermissions」に設定し、ファイル操作を許可する。これはサーバーサイドでの実行を前提としており、ユーザーが直接SDKを操作するわけではない。

### 環境変数の分離

SDK実行時に渡す環境変数は、必要最小限に制限する。機密情報は直接渡さず、IAMロールによる認証を推奨。

---

## 今後のセキュリティ強化候補

### 認証の強化

- OAuth 2.0 / OpenID Connect対応
- 多要素認証（MFA）対応
- APIキー管理

### 監査ログ

- 全APIアクセスの監査ログ記録
- 機密操作の詳細ログ
- ログの外部転送（SIEM連携）

### 分散ロック

- Redisによる分散ロックへの移行
- 複数インスタンス環境での整合性確保

### コンテンツスキャン

- アップロードファイルのウイルススキャン
- 不正コンテンツの検出
